\pagebreak
\section{Doacross Loop Nest}
\label{sec:doacross}

An \code{ordered} clause can be used on a loop construct with an integer
parameter argument, to define the number of associated loops within 
a \plc{doacross loop nest} where cross-iteration dependences exist.
A \code{depend} clause on an \code{ordered} construct within an ordered 
loop can be used to describe the dependences of the \plc{doacross loops}. 

In the code below
the \code{depend(sink:i-1)} clause specifies a wait point for the completion 
of computation from iteration \plc{i-1} before proceeding to the subsequent
statements. The \code{depend(source)} specifies that the current iteration
\plc{i} satisfies the cross-iteration dependence (\plc{i} to 
\plc{i-1} dependence). This example is equivalent 
to the use of the \code{ordered} construct without a clause in place of 
the \code{ordered} \code{depend} construct.

\cexample{doacross}{1}

\ffreeexample{doacross}{1}

The following code is similar to the previous example but with 
\plc{doacross loop nest} extended to two nested loops, \plc{i} and \plc{j}, 
as marked by the \code{ordered(2)} clause on the loop directive. 
The \code{depend(sink:i-1,j)} and \code{depend(sink:i,j-1)} (or
\code{depend(sink:j-1,i)} and \code{depend(sink:j,i-1)} in Fortran) clauses 
specify cross-iteration dependences (\plc{i} to \plc{i-1} and 
\plc{j} to \plc{j-1}) in two dimensions.
In the C/C++ code, the \plc{i} and \plc{j} loops are the first and
second associated loops, respectively, whereas
in the Fortran code, the \plc{j} and \plc{i} loops are the first and
second associated loops, respectively.

\cexample{doacross}{2}

\ffreeexample{doacross}{2}


The following example shows the incorrect use of the \code{ordered} 
\code{depend} directive.  There are two issues with the code.  The first
issue is a missing \code{ordered} \code{depend(source)} directive,
which could cause a deadlock.  The second issue is the presence of
lexicographically later dependences as indicated by the
\code{depend(sink:i+1,j)} and \code{depend(sink:i,j+1)} clauses,
which could cause a deadlock as well.
The two clauses define \plc{i} to \plc{i+1} and \plc{j} to \plc{j+1}
dependences where the \plc{i+1} or \plc{j+1} iteration is a later iteration
than the \plc{i} or \plc{j} iteration.

\cexample{doacross}{3}

\ffreeexample{doacross}{3}


The following example illustrates the use of the \code{collapse} clause for
a doacross loop nest.  The \plc{i} and \plc{j} loops are the associated
loops for the collapsed loop as well as for the doacross loop nest.
The example also shows a compliant usage of the dependence source
directive being placed before the corresponding sink directive.

\cexample{doacross}{4}

\ffreeexample{doacross}{4}
